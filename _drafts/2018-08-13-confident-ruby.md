---
layout: post
title:  "《优雅的Ruby》笔记"
date:   2018-08-13 23:22:30 +0800
categories: posts
---

* 第一章 引言

  * 我认为擅长讲故事的方法应该由上面提到的四个部分组成，而且它们之间应该做到泾渭分明，而不是混杂在一起的。但这还不够，它们的排列顺序也有要求：首先处理输入；接着实现核心功能；然后处理输出；如有需要，最后处理异常。

* 第二章 功能实现

  * 面向对象的基本特性除了类、集成、封装，还包括发送消息。对象之间的每一次交互都可以堪称一系列的消息发送。因此面向对象开发人员要做的就是决定发送什么消息，什么时候发送，以及谁负责响应。

  * 我并不推荐你写任何方法都遵循这种正规流程，但认清领域对象建模的本质还是很重要的。
    1. 尽可能地站在领域知识的角度，找出要发送的消息。
    2. 找出能恰当响应所发消息的角色。
    3. 尽可能将上述角色和已有对象关联起来。

* 第三章 收集输入

  * 间接输入层次越深，代码的耦合度就越高。当关联代码结构发生改变时，方法更有可能需要跟着改变。这其实就是众所周知的迪米特法则。

  * 3.2 使用内置的类型转换协议

    * 如果一个方法期望得到某个特定类型的输入（比如 Integer），则可使用 Ruby 的标准类型转换方法，以确保得到的输入都能满足预期。如果想让输入具有最大的灵活性，则可使用显式类型转换方法，如 #to_i；如果不想提供太大的灵活性，同时阻止调用者误用方法，则可使用隐式类型转换方法，如 #to_int。

  * 3.3 有条件地使用类型转换方法

  * 3.4 自定义类型转换协议

  * 3.5 定义自定义类型的转换协议

  * 3.6 利用内置强制类型转换方法

  * 3.7 用 Array() 将输入数组化

  * 3.8 自定义强制类型转换方法

  * 3.9 用自定义类替换类字符串类型

  * 3.10 用适配器装饰输入

  * 3.11 利用透明适配器逐步消除类型依赖

  * 3.12 利用先决条件排除非法输入

  * 3.13 利用 #fetch 确保 Hash 键的存在性

  * 3.14 利用 #fetch 提供默认参数

  * 3.15 用断言验证假设

  * 3.16 用卫语句来处理特殊场景

  * 3.17 用对象表示特殊场景

  * 3.18 用空对象表示不做事的情况

  * 3.19 用良性值替代 nil

  * 3.20 用 symbols 做占位符

  * 3.21 将参数封装到参数对象中

  * 3.22 提取参数构建器

* 第四章 输出处理

  * 4.1 用全函数作为方法返回值

  * 4.2 执行回调而非返回状态

  * 4.3 用良性值表示失败

  * 4.4 用特例对象表示失败

  * 4.5 返回状态对象

  * 4.6 将状态对象传给回调

  * 4.7 用 throw 提前终止执行

* 第五章 失败处理

  * 5.1 优先使用顶层异常捕获

  * 5.2 用受检方法封装危险操作

  * 5.3 使用护卫方法
